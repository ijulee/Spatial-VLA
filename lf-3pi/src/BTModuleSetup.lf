/**
 * Lingua Franca program for the Pololu 3pi+ 2040 to configure an HC-05 Bluetooth module.
 *
 * This program sends AT commands to change the HC-05's name and password.
 *
 * I-Jui: Disclaimer, this is adapted from LLM generated code with hallucinated nonsense fixed.
 *
 * Hardware Setup:
 * 1. GP28 (UART0 TX) -> HC-05 RXD
 * 2. GP29 (UART0 RX) -> HC-05 TXD
 * 3. 3V3 (OUT)       -> HC-05 VCC
 * 4. GND             -> HC-05 GND
 * 5. 3V3 (OUT)       -> HC-05 EN (only for AT mode to set name/pswd)
 *
 * How to use:
 * 1. Connect the HC-05 as described above.
 * 2. IMPORTANT: Power on the RP2040 (which powers the HC-05) ONLY AFTER
 * the KEY/EN pin is already connected to 3.3V. This boots the
 * module into AT command mode (baud rate 38400).
 * 3. Compile and flash this program to the 3pi+ 2040.
 * 4. Open the serial monitor (e.g., `screen -b 115200 /dev/ttyACM0`).
 * 5. The program will automatically send the commands.
 *
 */
target C {
    platform: {
        name: "rp2040",
        board: "pololu_3pi_2040_robot"
    },
    keepalive: true,
    threading: false
};

import Display from "lib/Display.lf"

preamble {=
    #include "pico/stdlib.h"
    #include <stdio.h>
    #include <hardware/uart.h>
    #include <hardware/irq.h>
    #include <string.h>
=}


main reactor {
    preamble {=
        // Define the UART for the HC-05
        #define UART_ID uart0
        #define BAUD_RATE 38400 // HC-05 AT mode baud rate
        #define DATA_BITS 8
        #define STOP_BITS 1
        #define PARITY    UART_PARITY_NONE

        // Define UART pins
        #define UART_TX_PIN 28
        #define UART_RX_PIN 29

        // Buffer to store response from HC-05
        #define RESP_BUF_SIZE 128
        volatile char response_buf[RESP_BUF_SIZE];
        volatile int response_idx = 0;
        volatile bool response_ready = false;

        // RX interrupt handler
        void on_uart_rx() {
            while (uart_is_readable(UART_ID)) {
                char ch = uart_getc(UART_ID);

                // Handle backspace/delete for basic terminal editing
                if (ch == '\b' || ch == 127) {
                    if (response_idx > 0) {
                        response_idx--;
                    }
                    continue; // Don't add the backspace to the buffer
                }

                if (response_idx < RESP_BUF_SIZE - 1) {
                    // End of command (Newline or Carriage Return)
                    if (ch == '\n' || ch == '\r') {
                        if (response_idx > 0) { // We have a command
                            response_buf[response_idx] = '\0'; // Null-terminate
                            response_ready = true;
                            response_idx = 0; // Reset for next command
                        }
                        // if index is 0, just ignore the newline
                    } else {
                        response_buf[response_idx++] = ch;
                    }
                }
            }
        }

        // Function to initialize UART0 for the HC-05
        void setup_uart() {
            // Initialize UART
            uart_init(UART_ID, BAUD_RATE);

            // Set the TX and RX pins
            gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
            gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

            // Set format
            uart_set_hw_flow(UART_ID, false, false);
            uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);

            // Turn off FIFO's - we want to do this character by character
            uart_set_fifo_enabled(UART_ID, false);

            // Set up and enable the RX interrupt
            int UART_IRQ = (UART_ID == uart0) ? UART0_IRQ : UART1_IRQ;
            irq_set_exclusive_handler(UART_IRQ, on_uart_rx);
            irq_set_enabled(UART_IRQ, true);

            // Enable the UART to fire an interrupt when data is received.
            uart_set_irq_enables(UART_ID, true, false);

            printf("Bluetooth UART initialized at %d baud.\n", BAUD_RATE);
        }

        // Function to send a command to the HC-05
        // All AT commands must end with \r\n
        void setup_msg(const char* msg) {
            printf("Sending: %s\n", msg);
            uart_puts(UART_ID, msg);
            uart_puts(UART_ID, "\r\n");
        }
    =}

    state cmd_step: int = 0;
    state new_name: string = "SVLM-bot";
    state new_pin: string = "1234";

    physical action command_delay; // Delay between commands
    physical action check_response; // Triggered by interrupt
    
    d = new Display();

    reaction(startup) -> command_delay, d.line0 {=
        // Initialize stdio over USB for printing
        stdio_init_all();
        
        // Start the command sequence after 5s
        // starting too quickly and the monitor won't catch it
        lf_schedule(command_delay, MSEC(5000));
    =}

    timer foo(0,1 sec);
    reaction (foo) {=
        printf("foo\n");
    =}

    reaction(command_delay) -> d.line0 {=
        char command_buffer[64];

        switch (self->cmd_step) {
            case 0:
                printf("RP2040 HC-05 Configurator Started.\n");
                lf_set(d.line0, "START");
                setup_uart();
                lf_schedule(command_delay, MSEC(1000));
                break;
            case 1:
                printf("\nStep 0: Sending AT (Test command)\n");
                lf_set(d.line0, "TEST");
                setup_msg("AT");
                break;
            case 2:
                printf("\nStep 1: Setting Name to '%s'\n", self->new_name);
                lf_set(d.line0, "NAME");
                snprintf(command_buffer, 64, "AT+NAME=%s", self->new_name);
                setup_msg(command_buffer);
                break;
            case 3:
                printf("\nStep 2: Setting PIN to '%s'\n", self->new_pin);
                lf_set(d.line0, "PSWD");
                // Note: PSWD changes the pairing code.
                snprintf(command_buffer, 64, "AT+PSWD=%s", self->new_pin);
                setup_msg(command_buffer);
                break;
            case 4:
                printf("\nStep 3: Setting UART setting to 9600,0,0\n");
                lf_set(d.line0, "UART");
                setup_msg("AT+UART=9600,0,0");
                break;
            case 5:
                printf("\nStep 4: Query UART settings\n");
                lf_set(d.line0, "UART?");
                setup_msg("AT+UART?");
                break;
            case 6:
                printf("\nStep 5: Querying new name\n");
                lf_set(d.line0, "NAME?");
                setup_msg("AT+NAME?");
                break;
            case 7:
                printf("\nStep 6: Querying new password\n");
                lf_set(d.line0, "PSWD?");
                setup_msg("AT+PSWD?");
                break;
            case 8:
                printf("\nConfiguration complete.\n");
                lf_set(d.line0, "DONE");
                // No more commands
                return;
        }

        self->cmd_step++;
    =}

    // This reaction is triggered by the UART RX interrupt
    // when a full line ('\n') has been received.
    reaction(check_response) -> command_delay, d.line1 {=
        if (response_ready) {
            printf("HC-05 Response: %s", (char*)response_buf); // Print the response
            char buf[17];
            snprintf(buf, 17, (char*)response_buf);
            lf_set(d.line1, buf);
            response_ready = false; // Clear the flag

            // Schedule the next command after a delay
            if (self->cmd_step < 9) {
                lf_schedule(command_delay, MSEC(1000));
            }
        }
    =}

    // This reaction polls the response_ready flag.
    // This is necessary because the interrupt handler (on_uart_rx)
    // cannot schedule a physical action directly.
    // We poll quickly to check the flag set by the ISR.
    timer poll_timer(0, 10 msec);
    reaction(poll_timer) -> check_response {=
        if (response_ready) {
            // Schedule the logical action to process the response
            lf_schedule(check_response, 0);
        }
    =}
}