/**
 * Lingua Franca program for the Pololu 3pi+ 2040 to configure an HC-05 Bluetooth module.
 *
 * This program sends AT commands to change the HC-05's name and password.
 *
 * I-Jui: Disclaimer, this is adapted from LLM generated code with hallucinated nonsense fixed.
 *
 * Hardware Setup:
 * 1. GP28 (UART0 TX) -> HC-05 RXD
 * 2. GP29 (UART0 RX) -> HC-05 TXD
 * 3. 3V3 (OUT)       -> HC-05 VCC
 * 4. GND             -> HC-05 GND
 * 5. 3V3 (OUT)       -> HC-05 EN (only for AT mode to set name/pswd)
 *
 * How to use:
 * 1. Connect the HC-05 as described above.
 * 2. IMPORTANT: Power on the RP2040 (which powers the HC-05) ONLY AFTER
 * the KEY/EN pin is already connected to 3.3V. This boots the
 * module into AT command mode (baud rate 38400).
 * 3. Compile and flash this program to the 3pi+ 2040.
 * 4. Open the serial monitor (e.g., `screen -b 115200 /dev/ttyACM0`).
 * 5. The program will automatically send the commands.
 *
 */
target C {
    platform: {
        name: "rp2040",
        board: "pololu_3pi_2040_robot"
    },
    keepalive: true,
    threading: false
};

import Display from "lib/Display.lf"

preamble {=
    #include "pico/stdlib.h"
    #include <stdio.h>
    #include <hardware/uart.h>
    #include <hardware/irq.h>
    #include <string.h>
=}


main reactor {
    preamble {=
        // Define the UART for the HC-05
        #define UART_ID uart0
        #define BAUD_RATE 38400 // HC-05 AT mode baud rate
        #define DATA_BITS 8
        #define STOP_BITS 1
        #define PARITY    UART_PARITY_NONE

        // Define UART pins
        #define UART_TX_PIN 28
        #define UART_RX_PIN 29

        // Buffer to store response from HC-05
        #define CMD_BUF_SIZE 128
        volatile char cmd_buf[CMD_BUF_SIZE];
        volatile int cmd_idx = 0;
        volatile bool cmd_ready = false;

        // RX interrupt handler
        void on_uart_rx() {
            while (uart_is_readable(UART_ID)) {
                char ch = uart_getc(UART_ID);

                printf("Got readable char: %d\n", (int) ch);

                // Handle backspace/delete for basic terminal editing
                if (ch == '\b' || ch == 127) {
                    if (cmd_idx > 0) {
                        cmd_idx--;
                    }
                    continue; // Don't add the backspace to the buffer
                }

                if (cmd_idx < CMD_BUF_SIZE - 1) {
                    // End of command (Newline or Carriage Return)
                    if (ch == '\n' || ch == '\r') {
                        if (cmd_idx > 0) { // We have a command
                            cmd_buf[cmd_idx] = '\0'; // Null-terminate
                            cmd_ready = true;
                            cmd_idx = 0; // Reset for next command
                        }
                        // if index is 0, just ignore the newline
                    } else {
                        cmd_buf[cmd_idx++] = ch;
                    }
                }
            }
        }

        // Function to initialize UART0 for the HC-05
        void setup_uart() {
            // Initialize UART
            uart_init(UART_ID, BAUD_RATE);

            // Set the TX and RX pins
            gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
            gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

            // Set format
            //uart_set_hw_flow(UART_ID, false, false);
            //uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);

            // Turn off FIFO's - we want to do this character by character
            //uart_set_fifo_enabled(UART_ID, false);

            // Set up and enable the RX interrupt
            int UART_IRQ = (UART_ID == uart0) ? UART0_IRQ : UART1_IRQ;
            irq_set_exclusive_handler(UART_IRQ, on_uart_rx);
            irq_set_enabled(UART_IRQ, true);

            // Enable the UART to fire an interrupt when data is received.
            uart_set_irq_enables(UART_ID, true, false);

            printf("Bluetooth UART initialized at %d baud.\n", BAUD_RATE);
        }

        // Function to send a command to the HC-05
        // All AT commands must end with \r\n
        void setup_msg(const char* msg) {
            printf("Sending: %s\n", msg);
            uart_puts(UART_ID, msg);
            uart_puts(UART_ID, "\r\n");
        }
    =}

    physical action get_next; // Delay between commands
    physical action cmd_received; // Triggered by interrupt
    
    timer delay_start(5 sec);

    d = new Display();

    reaction(startup) -> d.line0 {=
        lf_set(d.line0, "START");
    =}

    reaction(delay_start) -> d.line0 {=
        // Start the command sequence after 5s
        // starting too quickly and the serial monitor won't catch messages
        setup_uart();
        lf_set(d.line0, "WAITING...");
    =}

    // This reaction is triggered by the UART RX interrupt
    // when a full line ('\n') has been received.
    reaction(cmd_received) -> get_next, d.line0, d.line1 {=
        if (cmd_ready) {
            const string cmd = (const char*) cmd_buf;
            printf("Command received: %s", cmd); // Print the command
            static char buf[17];
            snprintf(buf, 17, cmd);
            lf_set(d.line1, buf);

            cmd_ready = false; // Clear the flag

            char ch = cmd[0];
            switch (ch) {
                case 'f':
                    lf_set(d.line0, "FORWARD");
                    break;
                case 'b':
                    lf_set(d.line0, "BACK");
                    break;
                case 'l':
                    lf_set(d.line0, "LEFT");
                    break;
                case 'r':
                    lf_set(d.line0, "RIGHT");
                    break;
                case 's':
                    lf_set(d.line0, "STOP");
                    break;
                default:
                    lf_set(d.line0, "UNKNOWN!");
                    break;
            }

            lf_schedule(get_next, MSEC(2000));
        }
    =}

    reaction (get_next) -> d.line0, d.line1 {=
        lf_set(d.line0, "WAITING...");
        lf_set(d.line1, "");
    =}
    // This reaction polls the cmd_ready flag.
    // This is necessary because the interrupt handler (on_uart_rx)
    // cannot schedule a physical action directly.
    // We poll quickly to check the flag set by the ISR.
    timer poll_timer(0, 10 msec);
    reaction(poll_timer) -> cmd_received {=
        if (cmd_ready) {
            // Schedule the logical action to process the response
            lf_schedule(cmd_received, 0);
        }
    =}
}