target C {
    platform: {
        name: "rp2040",
        board: "pololu_3pi_2040_robot"
    },
    keepalive: true,
    threading: false
}

import Display from "lib/Display.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import Encoders from "lib/Encoders.lf"
import GyroAngle from "lib/IMU.lf"

preamble {=
    #include <hardware/gpio.h>
    #include <hardware/uart.h>
    #include <hardware/irq.h>
    #include <pico/stdlib.h>
    #include <string.h>
    #include <stdlib.h>
    #include <stdio.h>

    #define GATE(a, x, b) (fmin(b, fmax(a, x)))
    #define MOVE_SPEED 0.04f
    #define TURN_SPEED 0.02f
=}

reactor EncoderDist {
    input angle_left: int32_t
    input angle_right: int32_t

    output left: float
    output right: float

    preamble {=
      #define PI   3.14159
      #define DIA  3.175
    =}
    
    reaction(angle_left, angle_right) -> left, right {=
      lf_set(left, (angle_left->value/360.0f) * PI * DIA);
      lf_set(right, (angle_right->value/360.0f) * PI * DIA);
    =}
  }

reactor Robot(sample_period: time = 100 ms) {
    input command: string

    state nextCommand: string = "";
    state speedMulti: float = 1;
    state startAngle: float
    state startDistL: float
    state startDistR: float

    state direction: int = 1;
    state speed: int = 0;
    state goal: int = 0;

    output notify0: string
    output notify1: string
    output notify2: string
    output notify3: string

    motor = new MotorsWithFeedback();
    encoder = new Encoders();
    dist = new EncoderDist();
    gyro = new GyroAngle();

    // sensor polling timer
    timer sampling(0, sample_period);
    timer get_command(0, 200 ms);

    // encoder to distance
    encoder.left -> dist.angle_left;
    encoder.right -> dist.angle_right;

    // encoder to motor feedback
    encoder.left -> motor.left;
    encoder.right -> motor.right;

    reaction (startup) -> notify0 {=
      self->startAngle = 0.0f;
      self->startDistL = 0.0f;
      self->startDistR = 0.0f;
    =}

    reaction (sampling) -> encoder.trigger, gyro.trigger {=
        // update distance
        lf_set(encoder.trigger, true);

        // update angle
        lf_set(gyro.trigger, true);
    =}

    reaction (command) -> notify0 {=
        self->nextCommand = command->value;
    =}

    initial mode DRIVE {
        reaction(get_command, gyro.z, dist.left, dist.right) -> reset(TURN) {=
            if (strcmp(self->nextCommand, "") == 0) {
                return;
            }

            // print command to serial output for debugging
            printf("command: %s\n", self->nextCommand);

            // parse command
            const string delim = ",";
            string token;
            string endstr;

            // mode: char
            token = strtok(self->nextCommand, delim);
            char cmd_mode = token[0];

            // speed: integer
            token = strtok(NULL, delim);
            int cmd_speed = strtol(token, &endstr, 10);

            // goal: integer
            token = strtok(NULL, delim);
            int cmd_goal = strtol(token, &endstr, 10);

            printf("parsed command: mode %c, speed %d, goal %d", cmd_mode, cmd_speed, cmd_goal);
        =}


    }

    mode TURN {

    }

    mode STOP {
        reaction(get_command, gyro.z, dist.left, dist.right) ->
            reset(FORWARD), reset(BACK), reset(RIGHT), reset(LEFT), reset(STOP) {=
            
            if (strcmp(self->nextCommand, "") == 0) {
                return;
            }

            printf("command: %s\n", self->nextCommand);

            switch (self->nextCommand[0]) {
                case 'f':
                lf_set_mode(FORWARD);
                break;
                
                case 'b':
                lf_set_mode(BACK);
                break;
                
                case 'l':
                lf_set_mode(LEFT);
                break;

                case 'r':
                lf_set_mode(RIGHT);
                break;

                case 's':
                lf_set_mode(STOP);
                break;

                default:
                return;
            }

            string cmdParameter = (self->nextCommand+1);
            char* endptr;
            long num = strtol(cmdParameter, &endptr, 10);
            self->speedMulti = (int) num;

            printf("multiplier: %d\n", self->speedMulti);

            self->startAngle = gyro.z->value;
            self->startDistL = dist.left->value;
            self->startDistR = dist.right->value;

            self->nextCommand = "";
        =}

        reaction(gyro.z, dist.left, dist.right) {=
            self->startAngle = gyro.z->value;
            self->startDistL = dist.left->value;
            self->startDistR = dist.right->value;
        
        =}
    }

    mode FORWARD {

        reaction(gyro.z) -> notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            /* The change in heading is proportional to the difference in distance traveled
            * between left and right wheel, which is integral of each wheel's speed.
            */
            float angleTurned = gyro.z->value - self->startAngle;
            float speedDiff = motor.left_speed->value - motor.right_speed->value;

            float factor = speedDiff * -0.002f + angleTurned * 0.001f;
            float newLeft = MOVE_SPEED + GATE(-MOVE_SPEED, factor, MOVE_SPEED);
            float newRight = MOVE_SPEED - GATE(-MOVE_SPEED, factor, MOVE_SPEED);
            lf_set(motor.left_speed, newLeft*self->speedMulti);
            lf_set(motor.right_speed, newRight*self->speedMulti);

            static char buf1[17], buf2[17], buf3[17];
            snprintf(buf3, 17, "z: %.1f", gyro.z->value);
            lf_set(notify3, buf3);
            snprintf(buf2, 17, "L: %.3f", newLeft*self->speedMulti);
            lf_set(notify2, buf2);
            snprintf(buf1, 17, "R: %.3f", newRight*self->speedMulti);
            lf_set(notify1, buf1);
        =}

        reaction(dist.left, dist.right) -> notify1, notify2 {=
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
        =}

        reaction(get_command, gyro.z, dist.left, dist.right) ->
            reset(FORWARD), reset(BACK), reset(RIGHT), reset(LEFT), reset(STOP) {=

            if (strcmp(self->nextCommand, "") == 0) {
                return;
            } 

            printf("command: %s\n", self->nextCommand);

            switch (self->nextCommand[0]) {
                case 'f':
                lf_set_mode(FORWARD);
                break;
                
                case 'b':
                lf_set_mode(BACK);
                break;
                
                case 'l':
                lf_set_mode(LEFT);
                break;

                case 'r':
                lf_set_mode(RIGHT);
                break;

                case 's':
                lf_set_mode(STOP);
                break;

                default:
                return;
            }

            string cmdParameter = (self->nextCommand+1);
            char* endptr;
            long num = strtol(cmdParameter, &endptr, 10);

            self->speedMulti = (int) num;
            
            self->startAngle = gyro.z->value;
            self->startDistL = dist.left->value;
            self->startDistR = dist.right->value;
            
            printf("multiplier: %d\n", self->speedMulti);

            self->nextCommand = "";
        =}
    }

    mode BACK {

        reaction(gyro.z) -> notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            /* The change in heading is proportional to the difference in distance traveled
            * between left and right wheel, which is integral of each wheel's speed.
            */
            float angleTurned = gyro.z->value - self->startAngle;
            float speedDiff = motor.left_speed->value - motor.right_speed->value;

            float factor = speedDiff * -0.002f + angleTurned * 0.001f;
            float newLeft = -MOVE_SPEED + GATE(-MOVE_SPEED, factor, MOVE_SPEED);
            float newRight = -MOVE_SPEED - GATE(-MOVE_SPEED, factor, MOVE_SPEED);
            lf_set(motor.left_speed, newLeft*self->speedMulti);
            lf_set(motor.right_speed, newRight*self->speedMulti);

            static char buf1[17], buf2[17], buf3[17];
            snprintf(buf3, 17, "z: %.1f", gyro.z->value);
            lf_set(notify3, buf3);
            snprintf(buf2, 17, "L: %.3f", newLeft*self->speedMulti);
            lf_set(notify2, buf2);
            snprintf(buf1, 17, "R: %.3f", newRight*self->speedMulti);
            lf_set(notify1, buf1);
        =}

        reaction(dist.left, dist.right) -> notify1, notify2 {=
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
        =}

        reaction(get_command, gyro.z, dist.left, dist.right) ->
            reset(FORWARD), reset(BACK), reset(RIGHT), reset(LEFT), reset(STOP) {=
            
            if (strcmp(self->nextCommand, "") == 0) {
                return;
            } 

            printf("command: %s\n", self->nextCommand);

            switch (self->nextCommand[0]) {
                case 'f':
                lf_set_mode(FORWARD);
                break;
                
                case 'b':
                lf_set_mode(BACK);
                break;
                
                case 'l':
                lf_set_mode(LEFT);
                break;

                case 'r':
                lf_set_mode(RIGHT);
                break;

                case 's':
                lf_set_mode(STOP);
                break;

                default:
                return;
            }

            string cmdParameter = (self->nextCommand+1);
            char* endptr;
            long num = strtol(cmdParameter, &endptr, 10);
            
            self->speedMulti = (int) num;
            
            self->startAngle = gyro.z->value;
            self->startDistL = dist.left->value;
            self->startDistR = dist.right->value;

            printf("multiplier: %d\n", self->speedMulti);

            self->nextCommand = "";
        =}
    }

    mode LEFT {

        reaction(gyro.z) -> notify3 {=
            float angleTurned = gyro.z->value - self->startAngle;
        =}

        reaction(dist.left, dist.right) -> 
            notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
            float factor = (distMovedL+distMovedR) * 0.0005f;
            float newLeft = -(TURN_SPEED + GATE(-TURN_SPEED, factor, TURN_SPEED));
            float newRight = (TURN_SPEED + GATE(-TURN_SPEED, factor, TURN_SPEED));

            static char buf1[17], buf2[17], buf3[17];
            sprintf(buf1, "d: %3.2f", distMovedL+distMovedR);
            sprintf(buf2, "L: %.3f", newLeft*self->speedMulti);
            sprintf(buf3, "R: %.3f", newRight*self->speedMulti);
            lf_set(notify3, buf1);
            lf_set(notify1, buf2);
            lf_set(notify2, buf3);


            lf_set(motor.left_speed, newLeft*self->speedMulti);
            lf_set(motor.right_speed, newRight*self->speedMulti);

        =}

        reaction(get_command, gyro.z, dist.left, dist.right) ->
            reset(FORWARD), reset(BACK), reset(RIGHT), reset(LEFT), reset(STOP) {=
            
            if (strcmp(self->nextCommand, "") == 0) {
                return;
            } 

            printf("command: %s\n", self->nextCommand);

            switch (self->nextCommand[0]) {
                case 'f':
                lf_set_mode(FORWARD);
                break;
                
                case 'b':
                lf_set_mode(BACK);
                break;
                
                case 'l':
                lf_set_mode(LEFT);
                break;

                case 'r':
                lf_set_mode(RIGHT);
                break;

                case 's':
                lf_set_mode(STOP);
                break;

                default:
                return;
            }

            string cmdParameter = (self->nextCommand+1);
            char* endptr;
            long num = strtol(cmdParameter, &endptr, 10);
            
            self->speedMulti = (int) num;
            
            self->startAngle = gyro.z->value;
            self->startDistL = dist.left->value;
            self->startDistR = dist.right->value;

            printf("multiplier: %d\n", self->speedMulti);

            self->nextCommand = "";
        =}
    }

    mode RIGHT {

        reaction(gyro.z) -> notify3 {=
            float angleTurned = gyro.z->value - self->startAngle;
        =}

        reaction(dist.left, dist.right) -> 
            notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
            float factor = (distMovedL+distMovedR) * 0.0005f;
            float newLeft = (TURN_SPEED + GATE(-TURN_SPEED, factor, TURN_SPEED));
            float newRight = -(TURN_SPEED + GATE(-TURN_SPEED, factor, TURN_SPEED));

            static char buf1[17], buf2[17], buf3[17];
            sprintf(buf1, "d: %3.2f", distMovedL+distMovedR);
            sprintf(buf2, "L: %.3f", newLeft*self->speedMulti);
            sprintf(buf3, "R: %.3f", newRight*self->speedMulti);
            lf_set(notify3, buf1);
            lf_set(notify1, buf2);
            lf_set(notify2, buf3);


            lf_set(motor.left_speed, newLeft*self->speedMulti);
            lf_set(motor.right_speed, newRight*self->speedMulti);

        =}

        reaction(get_command, gyro.z, dist.left, dist.right) ->
            reset(FORWARD), reset(BACK), reset(RIGHT), reset(LEFT), reset(STOP) {=
            
            if (strcmp(self->nextCommand, "") == 0) {
                return;
            } 

            printf("command: %s\n", self->nextCommand);

            switch (self->nextCommand[0]) {
                case 'f':
                lf_set_mode(FORWARD);
                break;
                
                case 'b':
                lf_set_mode(BACK);
                break;
                
                case 'l':
                lf_set_mode(LEFT);
                break;

                case 'r':
                lf_set_mode(RIGHT);
                break;

                case 's':
                lf_set_mode(STOP);
                break;

                default:
                return;
            }

            string cmdParameter = (self->nextCommand+1);
            char* endptr;
            long num = strtol(cmdParameter, &endptr, 10);
            
            self->speedMulti = (int) num;
            
            self->startAngle = gyro.z->value;
            self->startDistL = dist.left->value;
            self->startDistR = dist.right->value;
            
            printf("multiplier: %d\n", self->speedMulti);

            self->nextCommand = "";
        =}
    }
}

reactor BTReceiver {
    preamble {=
        // Define the UART for the HC-05
        #define UART_ID     uart0
        #define BAUD_RATE   9600
        #define DATA_BITS   8
        #define STOP_BITS   1
        #define PARITY      UART_PARITY_NONE

        // Define UART pins
        #define UART_TX_PIN 28
        #define UART_RX_PIN 29

         // --- Ring Buffer for ISR-driven UART ---
         #define RING_BUF_SIZE 256
        volatile char uart_ring_buffer[RING_BUF_SIZE];
        volatile uint ring_head = 0;
        volatile uint ring_tail = 0;

        // --- Line Buffer for Main Loop ---
        #define LINE_BUF_SIZE 128
        volatile char uart_line_buffer[LINE_BUF_SIZE];
        volatile int line_idx = 0;
        volatile bool line_ready = false;

        // RX interrupt handler (ISR)
        void on_uart_rx() {
            while (uart_is_readable(UART_ID)) {
                char ch = uart_getc(UART_ID);

                // calculate next head position
                uint next_head = (ring_head + 1) % RING_BUF_SIZE;

                // check if buffer is full
                if (next_head != ring_tail) {
                    // not full, add char to buffer
                    uart_ring_buffer[ring_head] = ch;
                    ring_head = next_head;
                }
                // else buffer full, char dropped
            }
        }

        // initialize UART0 for the HC-05
        void setup_uart() {
            // initialize UART
            uart_init(UART_ID, BAUD_RATE);

            // set the TX and RX pins
            gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
            gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

            // set format
            uart_set_hw_flow(UART_ID, false, false);
            uart_set_format(UART_ID, DATA_BITS, STOP_BITS, PARITY);

            // turn off FIFO; char-by-char
            uart_set_fifo_enabled(UART_ID, false);

            // set up and enable RX interrupt
            int UART_IRQ = (UART_ID == uart0) ? UART0_IRQ : UART1_IRQ;
            irq_set_exclusive_handler(UART_IRQ, on_uart_rx);
            irq_set_enabled(UART_IRQ, true);

            // enable UART to fire an interrupt when data received
            uart_set_irq_enables(UART_ID, true, false);

            printf("Bluetooth UART initialized at %d baud.\n", BAUD_RATE);
        }

        // send message to HC-05 (end with CRLF)
        void setup_msg(const char* msg) {
            printf("Sending: %s\n", msg);
            uart_puts(UART_ID, msg);
            uart_puts(UART_ID, "\r\n");
        }
    =}

    state cur_state: char = 's';
    state count: int = 0
    
    output command: string

    timer poll_timer(0, 10 msec);

    physical action cmd_received;

    // regularly poll for chars from BT module
    reaction(poll_timer) -> cmd_received {=
        // do not process if main loop hasn't processed last line
        if (line_ready) {
            return;
        }

        // process characters from ring buffer
        while (ring_tail != ring_head) {
            char ch = uart_ring_buffer[ring_tail];
            ring_tail = (ring_tail + 1) % RING_BUF_SIZE;

            // handle bksp/del for basic terminal editing
            if (ch == '\b' || ch == 127) {
                if (line_idx > 0) {
                    line_idx--;
                }
                continue; // don't add to buffer
            }

            // treat \n or \r as line end
            if (ch == '\n' || ch == '\r') {
                if (line_idx > 0) { // complete line
                    uart_line_buffer[line_idx] = '\0'; // null terminate
                    line_ready = true;
                    line_idx = 0; // reset for next line
                    
                    // schedule physical action
                    lf_schedule(cmd_received, 0);
                    
                    // stop processing chars for now
                    break;
                }
                // else empty line, just ignore
            } else {
                // regular char
                if (line_idx < LINE_BUF_SIZE - 1) {
                    uart_line_buffer[line_idx++] = ch;
                } else {
                    // buffer overflow and reset.
                    line_idx = 0;
                }
            }
        }
    =}

    // triggered when a full line has been received
    reaction(cmd_received) -> command {=
        // read the line buffer
        const char* cmd = (const char*) uart_line_buffer;

        // print to USB serial output for debugging
        printf("Command Received: '%s'\n", cmd);

        lf_set(command, cmd);

        // clear line_ready flag after processing
        line_ready = false; 
    =}
}

main reactor {
    robot = new Robot()
    display = new Display()
    rcvr = new BTReceiver()

    rcvr.command -> robot.command

    robot.notify0 -> display.line0
    robot.notify1 -> display.line1
    robot.notify2 -> display.line2
    robot.notify3 -> display.line3

}