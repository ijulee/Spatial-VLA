target C {
    platform: {
        name: "rp2040",
        board: "pololu_3pi_2040_robot"
    },
    single-threaded: true
}

import Display from "lib/Display.lf"
import MotorsWithFeedback from "lib/MotorsWithFeedback.lf"
import Encoders from "lib/Encoders.lf"
import GyroAngle from "lib/IMU.lf"

preamble {=
    #include <hardware/gpio.h>
    #include <pico/stdlib.h>

    #define SIGMOID(x) (1.0f/(1+exp(-x))-0.5f)
    #define GATE(a, x, b) (fmin(b, fmax(a, x)))
    #define MOVE_SPEED 0.05f
    #define TURN_SPEED 0.01f
=}

reactor EncoderDist {
    input angle_left: int32_t
    input angle_right: int32_t

    output left: float
    output right: float

    preamble {=
      #define PI   3.14159
      #define DIA  3.175
    =}
    
    reaction(angle_left, angle_right) -> left, right {=
      lf_set(left, (angle_left->value/360.0f) * PI * DIA);
      lf_set(right, (angle_right->value/360.0f) * PI * DIA);
    =}
  }

reactor Robot(sample_period: time = 100 ms) {
    input command: string

    state lastCommand: string = "s";
    state startAngle: float
    state startDistL: float
    state startDistR: float

    output notify0: string
    output notify1: string
    output notify2: string
    output notify3: string

    motor = new MotorsWithFeedback();
    encoder = new Encoders();
    dist = new EncoderDist();
    gyro = new GyroAngle();

    // sensor polling timer
    timer sampling(0, 100 ms);
    timer get_command(200 ms);

    // encoder to distance
    encoder.left -> dist.angle_left;
    encoder.right -> dist.angle_right;

    // encoder to motor feedback
    encoder.left -> motor.left;
    encoder.right -> motor.right;

    reaction (startup) -> notify0 {=
      self->startAngle = 0.0f;
      self->startDistL = 0.0f;
      self->startDistR = 0.0f;
      lf_set(notify0, "started");
    =}

    reaction (sampling) -> encoder.trigger, gyro.trigger/*, accel.trigger*/ {=
        // update distance
        lf_set(encoder.trigger, true);

        // update angle
        lf_set(gyro.trigger, true);
    =}

    initial mode WAIT {
        // wait to receive a command
        timer timeout(50 ms) 

        reaction (command) -> 
            notify0, motor.left_speed, motor.right_speed,
            reset(FORWARD), reset(BACK), reset(RIGHT), reset(LEFT), reset(WAIT) {=
        
        string next_command;

        if(command->is_present) {
            next_command = command->value;
        } else { // timed out, continue last command
            next_command = self->lastCommand;
        }

        self->lastCommand = next_command;
        // static char buf[17];
        // sprintf(buf, 17, next_command);
        lf_set(notify0, next_command);

        switch (next_command[0]) {
            case 'f':
            lf_set(motor.left_speed, MOVE_SPEED);
            lf_set(motor.right_speed, MOVE_SPEED);
            lf_set_mode(FORWARD);
            break;
            
            case 'b':
            lf_set(motor.left_speed, -MOVE_SPEED);
            lf_set(motor.right_speed, -MOVE_SPEED);
            lf_set_mode(BACK);
            break;
            
            case 'l':
            lf_set(motor.left_speed, -TURN_SPEED);
            lf_set(motor.right_speed, TURN_SPEED);
            lf_set_mode(LEFT);
            break;

            case 'r':
            lf_set(motor.left_speed, TURN_SPEED);
            lf_set(motor.right_speed, -TURN_SPEED);
            lf_set_mode(RIGHT);
            break;

            case 's':
            lf_set(motor.left_speed, 0.0f);
            lf_set(motor.right_speed, 0.0f);
            lf_set_mode(WAIT);
            break;

            default:
            return;
        }

        =}

        reaction(gyro.z, dist.left, dist.right) {=
        
        self->startAngle = gyro.z->value;
        self->startDistL = dist.left->value;
        self->startDistR = dist.right->value;
        
        =}
    }

    mode FORWARD {

        reaction(gyro.z) -> notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            float angleTurned = gyro.z->value - self->startAngle + 10;

            /* The change in heading is proportional to the difference in distance traveled
            * between left and right wheel, which is integral of each wheel's speed.
            */
            float leftSpeed = motor.left_speed->value;
            float rightSpeed = motor.right_speed->value;
            float factor = rightSpeed-leftSpeed * 0.001f + angleTurned * 0.02f;
            float newLeft = MOVE_SPEED + GATE(-2*MOVE_SPEED, leftSpeed + factor, 2*MOVE_SPEED);
            float newRight = MOVE_SPEED + GATE(-2*MOVE_SPEED, rightSpeed - factor, 2*MOVE_SPEED);
            lf_set(motor.left_speed, newLeft);
            lf_set(motor.right_speed, newRight);

            static char buf1[17], buf2[17], buf3[17];
            snprintf(buf3, 17, "z: %.1f", gyro.z->value);
            lf_set(notify3, buf3);
            snprintf(buf2, 17, "L: %.3f", newLeft);
            lf_set(notify2, buf2);
            snprintf(buf1, 17, "R: %.3f", newRight);
            lf_set(notify1, buf1);
        =}

        reaction(dist.left, dist.right) -> notify1, notify2 {=
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
        =}

        // reaction(get_command) -> reset(WAIT) {=
            // lf_set_mode(WAIT);
        // =}
    }

    mode BACK {

        reaction(gyro.z) -> notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            float angleTurned = gyro.z->value - self->startAngle;

            /* The change in heading is proportional to the difference in distance traveled
            * between left and right wheel, which is integral of each wheel's speed.
            */
            float leftSpeed = motor.left_speed->value;
            float rightSpeed = motor.right_speed->value;
            float factor = SIGMOID(leftSpeed-rightSpeed) * -0.001f + SIGMOID(angleTurned) * 0.005f;
            float newLeft = motor.left_speed->value + factor;
            float newRight = motor.right_speed->value - factor;
            lf_set(motor.left_speed, newLeft);
            lf_set(motor.right_speed, newRight);

            static char buf1[17], buf2[17], buf3[17];
            snprintf(buf3, 17, "z: %.1f", gyro.z->value);
            lf_set(notify3, buf3);
            snprintf(buf2, 17, "L: %.3f", newLeft);
            lf_set(notify2, buf2);
            snprintf(buf1, 17, "R: %.3f", newRight);
            lf_set(notify1, buf1);
        =}

        reaction(dist.left, dist.right) -> notify1, notify2 {=
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
        =}

        // reaction(get_command) -> reset(WAIT) {=
        //     lf_set_mode(WAIT);
        // =}
    }

    mode LEFT {

        reaction(gyro.z) -> notify3 {=
            float angleTurned = gyro.z->value - self->startAngle;
        =}

        reaction(dist.left, dist.right) -> 
            notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
        
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
            float factor = SIGMOID(distMovedL-distMovedR) * 0.001;
            float newLeft = motor.left_speed->value - factor;
            float newRight = motor.right_speed->value - factor;
            static char buf1[17], buf2[17], buf3[17];
            sprintf(buf1, "%3.2f", distMovedL-distMovedR);
            sprintf(buf2, "%.3f", newLeft);
            sprintf(buf3, "%.3f", newRight);

            lf_set(notify1, buf1);
            lf_set(notify2, buf2);
            lf_set(notify3, buf3);


            lf_set(motor.left_speed, newLeft);
            lf_set(motor.right_speed, newRight);

        =}

        // reaction(get_command) -> reset(WAIT) {=
        //     lf_set_mode(WAIT);

        // =}
    }

    mode RIGHT {

        reaction(gyro.z) -> notify3 {=
            float angleTurned = gyro.z->value - self->startAngle;
        =}

        reaction(dist.left, dist.right) -> 
            notify1, notify2, notify3, motor.left_speed, motor.right_speed {=
            float distMovedL = dist.left->value - self->startDistL;
            float distMovedR = dist.right->value - self->startDistR;
            float factor = SIGMOID(distMovedL-distMovedR) * 0.001;
            float newLeft = motor.left_speed->value - factor;
            float newRight = motor.right_speed->value - factor;

            static char buf1[17], buf2[17], buf3[17];
            sprintf(buf1, "%3.2f", distMovedL-distMovedR);
            sprintf(buf2, "%.3f", newLeft);
            sprintf(buf3, "%.3f", newRight);

            lf_set(notify1, buf1);
            lf_set(notify2, buf2);
            lf_set(notify3, buf3);


            lf_set(motor.left_speed, newLeft);
            lf_set(motor.right_speed, newRight);

        =}

        // reaction(get_command) -> reset(WAIT) {=
        //     lf_set_mode(WAIT);

        // =}
    }
}

reactor BTReceiver {
    //input enable: bool
    output command: string
    
    state count: int = 0

    timer t(0, 200ms)

    reaction(t) -> command {=
        switch (self->count) {
            case 0:
            lf_set(command, "f 10\n");
            break;

            case 15:
            //lf_set(command, "b 20\n");
            break;

            case 25:
            //lf_set(command, "r 5\n");
            break;
        }
        self->count++;
    =}
}

main reactor {
    robot = new Robot()
    display = new Display()
    rcvr = new BTReceiver()

    robot.notify0 -> display.line0
    robot.notify1 -> display.line1
    robot.notify2 -> display.line2
    //rcvr.command -> display.line3
    robot.notify3 -> display.line3

    rcvr.command -> robot.command
}